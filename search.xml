<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ZAB协议</title>
    <url>/2024/10/08/ZAB%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="什么是ZAB协议？"><a href="#什么是ZAB协议？" class="headerlink" title="什么是ZAB协议？"></a>什么是ZAB协议？</h3><p>　ZAB（ZooKeeper Atomic Broadcast）协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议，实现分布式数据一致性。只有一台客户端（Leader）负责处理外部的写事务请求，然后 Leader 客户端将数据同步到其他Follower节点。即Zookeeper只有一个Leader可以发起提案（Proposal）。</p>
<h3 id="崩溃恢复和消息广播"><a href="#崩溃恢复和消息广播" class="headerlink" title="崩溃恢复和消息广播"></a>崩溃恢复和消息广播</h3><h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><ol>
<li>Leader节点处理所有事务请求，将客户端请求转换为提案（Proposal），并广播给所有Follower节点。</li>
<li>Leader等待大部分Follower节点反馈后，再次广播Commit信息，确认之前的Proposal提交。</li>
<li>Zab协议的核心，就是只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交Proposal。</li>
</ol>
<p><img src="/../img/articles/zk/ZAB%E5%8D%8F%E8%AE%AE.png" alt="ZAB协议"></p>
<h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p><strong>什么情况下会进入崩溃恢复模式</strong></p>
<ul>
<li>当服务器启动时</li>
<li>当leader 服务器出现网络中断，崩溃或者重启的情况</li>
<li>当集群中已经不存在过半的服务器与Leader服务器保持正常通信。</li>
</ul>
<p><strong>特殊情况下会发生的情况</strong></p>
<p><strong>一、已经被处理的事务请求不能丢失：</strong><br>　当Leader在收到大多数Follower的确认后，广播Commit命令并本地执行，但如果在Follower收到Commit之前Leader宕机，可能导致部分Follower没有执行该事务。</p>
<p>解决方案：</p>
<ul>
<li>选举具有最大zxid（提案最大值）的节点作为新的Leader，因为它保存了所有已提交的Proposal。</li>
<li>新的Leader处理自己日志中的未提交事务，并将这些Proposal发送给Follower，确保所有Follower都同步执行。</li>
</ul>
<p><strong>二、未被处理的事务请求不能再次出现：</strong><br>　当Leader生成Proposal后宕机，部分Follower没有收到该Proposal，重新选举后，这些Proposal会被跳过。如果宕机的旧Leader重启并成为Follower，它的状态可能和系统不一致。</p>
<p>解决方案：</p>
<ul>
<li>通过zxid的设计，旧的Leader重启后不会被选为Leader，因为它的zxid小于新的Leader。</li>
<li>当旧Leader作为Follower加入时，新的Leader会指示它清除未提交的旧事务，避免状态不一致。</li>
</ul>
<h3 id="事务编号Zxid"><a href="#事务编号Zxid" class="headerlink" title="事务编号Zxid"></a>事务编号Zxid</h3><p><strong>zxid定义</strong>：<br>　在ZAB协议中，<code>zxid</code>是一个64位的事务编号，用于唯一标识每个事务。它确保了系统中事务的顺序和一致性。</p>
<p><strong>zxid的组成</strong>：<br>　<code>zxid</code>由两部分构成：</p>
<ol>
<li><strong>高32位</strong>：表示<code>epoch编号</code>，用于标识当前Leader的任期。每次选举产生新的Leader时，<code>epoch</code>值会加1，确保旧的Leader无法继续影响系统。</li>
<li><strong>低32位</strong>：表示<code>事务计数器</code>，用于标识Leader在同一任期内生成的事务数量。Leader每处理一个新的客户端请求，该计数器都会自增1。</li>
</ol>
<p><strong>epoch编号的作用</strong>：<br>　<code>epoch</code>编号用于区别不同的Leader任期。每次选举新的Leader时，新Leader会根据自己本地最大事务的<code>zxid</code>，解析出当前的<code>epoch</code>编号，并在此基础上加1。Follower只服从<code>epoch</code>最大的Leader，确保旧的Leader不会影响新任期的操作。</p>
<p><strong>zxid的增长机制</strong>：</p>
<ul>
<li>新选举出的Leader会将自身日志中最大的<code>zxid</code>解析出<code>epoch</code>编号，加1后作为新的<code>epoch</code>。</li>
<li>事务计数器（低32位）归零，并从0开始对每个新事务递增。</li>
</ul>
<p><strong>zxid的作用</strong>：</p>
<ol>
<li><strong>事务顺序控制</strong>：<code>zxid</code>保证了每个事务在系统中的全局顺序。</li>
<li><strong>Leader合法性判断</strong>：通过<code>epoch</code>编号，Follower可以识别出当前的合法Leader，确保系统的稳定性和一致性。</li>
</ol>
<h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><ol>
<li><p>Looking &#x2F;Election：系统刚启动时或者Leader崩溃后正处于选举状态</p>
</li>
<li><p>Following ：Follower节点所处的状态，Follower与Leader处于数据同步阶段；</p>
</li>
<li><p>Leading ：Leader所处状态，当前集群中有一个Leader为主进程；</p>
</li>
</ol>
<p><img src="/../img/articles/zk/ZAB%E5%8D%8F%E8%AE%AE-%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81.png" alt="ZAB协议-节点状态"></p>
<h4 id="启动时期选举"><a href="#启动时期选举" class="headerlink" title="启动时期选举"></a>启动时期选举</h4><ul>
<li>每个服务器发出一张选票，第一轮都投给自己。</li>
<li>接受来自各个服务器的选票。</li>
<li>处理选票，首先检查<code>zxid</code>（事务ID），如果相同则比较<code>myid</code>（服务器ID）。</li>
<li>统计选票，判断是否已经有过半的机器接收到相同的选票信息。</li>
<li>如果有过半机器接收相同的选票信息，则改变服务器状态：<code>Leader -&gt; Leading</code>，<code>Follower -&gt; Following</code></li>
</ul>
<h4 id="服务运行时选举"><a href="#服务运行时选举" class="headerlink" title="服务运行时选举"></a>服务运行时选举</h4><ul>
<li>当Leader挂掉后，剩下的Follower都变成<code>Looking</code>状态，进入Leader选举过程。</li>
<li>每个服务器发出一张选票，第一轮都投给自己，然后将自己的选票发送给所有机器。</li>
<li>接收选票，并进行选票处理，与启动选举相同。</li>
<li>统计选票，与启动选举相同。</li>
<li>如果有过半机器接收相同的选票信息，则改变服务器状态，与启动选举相同。</li>
</ul>
<h4 id="FastLeaderElection算法"><a href="#FastLeaderElection算法" class="headerlink" title="FastLeaderElection算法"></a>FastLeaderElection算法</h4><p><strong>基本信息</strong>：</p>
<ul>
<li><strong>投票信息</strong>：包含两个重要元素：服务器唯一标识（<code>sid</code>）和事务ID（<code>zxid</code>）。</li>
<li><strong>逻辑时钟</strong>：用来标识选举轮次，重启时为0，选举时加1。</li>
</ul>
<p><strong>选举状态</strong>：</p>
<ul>
<li>初始状态为<strong>Looking</strong>，表示系统正在进行Leader选举。</li>
</ul>
<p><strong>选举过程</strong>：</p>
<ul>
<li>每台机器在第一次投票时将自己作为被推举对象，广播选票（包含<code>clock</code>、状态、<code>zxid</code>和<code>myid</code>）。</li>
<li>收到其他节点的投票后：<ul>
<li>如果接收到的<code>clock</code>大于自己的，更新自己的<code>clock</code>。</li>
<li>如果接收到的<code>zxid</code>大于自己的，认可该节点的投票，更新选票为该节点。</li>
<li>如果<code>zxid</code>小于自己的，保持原选票。</li>
<li>如果<code>zxid</code>相等，比较<code>myid</code>，选择较大的节点。</li>
</ul>
</li>
</ul>
<p><strong>重新发出选票</strong>：</p>
<ul>
<li>经过第二轮投票后，各节点统计收到的投票，如果某个节点收到超过半数的相同投票，该节点即为新的Leader。</li>
</ul>
<p><strong>选举结果</strong>：</p>
<ul>
<li>通常数据更新较新的节点更有可能成为Leader，因为它能更好地保证数据的一致性和恢复。</li>
<li>若多个节点有相同的<code>zxid</code>，则<code>myid</code>较大的节点优先成为Leader。</li>
</ul>
]]></content>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper源码解析（一）：探索核心类QuorumPeerMain</title>
    <url>/2024/11/03/Zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%8E%A2%E7%B4%A2%E6%A0%B8%E5%BF%83%E7%B1%BBQuorumPeerMain/</url>
    <content><![CDATA[<h3 id="如何入手Zookeeper源码？"><a href="#如何入手Zookeeper源码？" class="headerlink" title="如何入手Zookeeper源码？"></a>如何入手Zookeeper源码？</h3><p>​	我们阅读源码的时候，可以从启动脚本开始进行分析。我们通过zkServer.sh这个脚本可以发现，核心类就是org.apache.zookeeper.server.quorum.QuorumPeerMain。</p>
<h3 id="QuorumPeerMain整体分析"><a href="#QuorumPeerMain整体分析" class="headerlink" title="QuorumPeerMain整体分析"></a>QuorumPeerMain整体分析</h3><p>我们直接来看initializeAndRun()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeAndRun</span><span class="params">(String[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> ConfigException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个用于解析配置文件的类</span></span><br><span class="line">        <span class="type">QuorumPeerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuorumPeerConfig</span>();</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="comment">// 如果发现那你的命令行里仅仅给他传递了一个参数的话</span></span><br><span class="line">            <span class="comment">// 此时就认为你传递的就是zoo.cfg配置文件</span></span><br><span class="line">            <span class="comment">// 就用QuorumPeerConfig类的parse()方法去解析zoo.cfg这个类</span></span><br><span class="line">            config.parse(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">        <span class="comment">// 就是启动后台线程，定期清理zk的日志文件和快照文件</span></span><br><span class="line">        <span class="type">DatadirCleanupManager</span> <span class="variable">purgeMgr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatadirCleanupManager</span>(config</span><br><span class="line">                .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">                .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">        purgeMgr.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果说发现你传递进来了一个zoo.cfg配置文件</span></span><br><span class="line">        <span class="comment">// 并且配置了servers参数，就说明你配置了一个zk集群</span></span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.servers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 集群的模式来启动这个zk节点</span></span><br><span class="line">            runFromConfig(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Either no config or no quorum defined in config, running &quot;</span></span><br><span class="line">                    + <span class="string">&quot; in standalone mode&quot;</span>);</span><br><span class="line">            <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">            <span class="comment">// 启动单机版本的zk</span></span><br><span class="line">            ZooKeeperServerMain.main(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// JMX相关的bean，无需理会</span></span><br><span class="line">          ManagedUtil.registerLog4jMBeans();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (JMException e) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Unable to register log4j JMX control&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      LOG.info(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 会启动一个server，监听2888端口</span></span><br><span class="line">          <span class="comment">// 让客户端跟他建立连接，发送请求</span></span><br><span class="line">          <span class="type">ServerCnxnFactory</span> <span class="variable">cnxnFactory</span> <span class="operator">=</span> ServerCnxnFactory.createFactory();</span><br><span class="line">          cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">                                config.getMaxClientCnxns());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这个QuorumPeer代表了一个zk节点</span></span><br><span class="line">          quorumPeer = <span class="keyword">new</span> <span class="title class_">QuorumPeer</span>();</span><br><span class="line">          quorumPeer.setClientPortAddress(config.getClientPortAddress());</span><br><span class="line">          <span class="comment">// FileTxnSnapLog 磁盘数据管理组件</span></span><br><span class="line">          quorumPeer.setTxnFactory(<span class="keyword">new</span> <span class="title class_">FileTxnSnapLog</span>(</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">File</span>(config.getDataLogDir()),</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">File</span>(config.getDataDir())));</span><br><span class="line">          quorumPeer.setQuorumPeers(config.getServers());</span><br><span class="line">          quorumPeer.setElectionType(config.getElectionAlg());</span><br><span class="line">          quorumPeer.setMyid(config.getServerId());</span><br><span class="line">          quorumPeer.setTickTime(config.getTickTime());</span><br><span class="line">          quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</span><br><span class="line">          quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</span><br><span class="line">          quorumPeer.setInitLimit(config.getInitLimit());</span><br><span class="line">          quorumPeer.setSyncLimit(config.getSyncLimit());</span><br><span class="line">          quorumPeer.setQuorumVerifier(config.getQuorumVerifier());</span><br><span class="line">          quorumPeer.setCnxnFactory(cnxnFactory);</span><br><span class="line">          <span class="comment">// ZKDatabase zk内存数据库</span></span><br><span class="line">          quorumPeer.setZKDatabase(<span class="keyword">new</span> <span class="title class_">ZKDatabase</span>(quorumPeer.getTxnFactory()));</span><br><span class="line">          quorumPeer.setLearnerType(config.getPeerType());</span><br><span class="line">  </span><br><span class="line">          quorumPeer.start();</span><br><span class="line">          <span class="comment">// 线程在这里hang住了</span></span><br><span class="line">          quorumPeer.join();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">          LOG.warn(<span class="string">&quot;Quorum Peer interrupted&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我们来看一下QuorumPeer的start()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复内存数据</span></span><br><span class="line">        loadDataBase();</span><br><span class="line">        cnxnFactory.start();   </span><br><span class="line">        <span class="comment">// 开启leader的选举，只是为leader选举做好初始化的准备工作而已，并没有真实的执行</span></span><br><span class="line">        startLeaderElection(); </span><br><span class="line">        <span class="built_in">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为QuorumPeer也是一个线程，所以最后会运行它的run()方法。这段大概得意思就是根据节点当前的状态，去执行对应的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        setName(<span class="string">&quot;QuorumPeer&quot;</span> + <span class="string">&quot;[myid=&quot;</span> + getId() + <span class="string">&quot;]&quot;</span> +</span><br><span class="line">                cnxnFactory.getLocalAddress());</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&quot;Starting quorum peer&quot;</span>);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// ...  这块又是注册一些jmx的bean，直接略过</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Main loop</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">                <span class="comment">// 1.如果是刚开始启动的话，状态都是LOOKING，在寻找leader的状态</span></span><br><span class="line">                <span class="comment">// 2.如果说没有leader，此时你就要发起投票给其他所有人去尝试选举leader</span></span><br><span class="line">                <span class="comment">// 3.如果已经有了一个leader了，此时就让自己作为follower</span></span><br><span class="line">                <span class="keyword">case</span> LOOKING:</span><br><span class="line">                    LOG.info(<span class="string">&quot;LOOKING&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 是否启用一个只读模式</span></span><br><span class="line">                    <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;readonlymode.enabled&quot;</span>)) &#123;</span><br><span class="line">                        LOG.info(<span class="string">&quot;Attempting to start ReadOnlyZooKeeperServer&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Create read-only server but don&#x27;t start it immediately</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="type">ReadOnlyZooKeeperServer</span> <span class="variable">roZk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyZooKeeperServer</span>(</span><br><span class="line">                                logFactory, <span class="built_in">this</span>,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">ZooKeeperServer</span>.BasicDataTreeBuilder(),</span><br><span class="line">                                <span class="built_in">this</span>.zkDb);</span><br><span class="line">    </span><br><span class="line">                        <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                        <span class="comment">// period before we decide we&#x27;re partitioned.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                        <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                        <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                        <span class="type">Thread</span> <span class="variable">roZkMgr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                    sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                    <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                        roZk.startup();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    LOG.info(<span class="string">&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                    LOG.error(<span class="string">&quot;FAILED to start ReadOnlyZooKeeperServer&quot;</span>, e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            roZkMgr.start();</span><br><span class="line">                            <span class="comment">// 都要执行这行代码</span></span><br><span class="line">                            setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                            setPeerState(ServerState.LOOKING);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                            <span class="comment">// to come out of waiting.</span></span><br><span class="line">                            roZkMgr.interrupt();</span><br><span class="line">                            roZk.shutdown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 都要执行这行代码</span></span><br><span class="line">                            setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                            setPeerState(ServerState.LOOKING);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OBSERVING:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOG.info(<span class="string">&quot;OBSERVING&quot;</span>);</span><br><span class="line">                        setObserver(makeObserver(logFactory));</span><br><span class="line">                        observer.observeLeader();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e );                        </span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        observer.shutdown();</span><br><span class="line">                        setObserver(<span class="literal">null</span>);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FOLLOWING:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOG.info(<span class="string">&quot;FOLLOWING&quot;</span>);</span><br><span class="line">                        setFollower(makeFollower(logFactory));</span><br><span class="line">                        follower.followLeader();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        follower.shutdown();</span><br><span class="line">                        setFollower(<span class="literal">null</span>);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LEADING:</span><br><span class="line">                    LOG.info(<span class="string">&quot;LEADING&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        setLeader(makeLeader(logFactory));</span><br><span class="line">                        leader.lead();</span><br><span class="line">                        setLeader(<span class="literal">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader != <span class="literal">null</span>) &#123;</span><br><span class="line">                            leader.shutdown(<span class="string">&quot;Forcing shutdown&quot;</span>);</span><br><span class="line">                            setLeader(<span class="literal">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;QuorumPeer main thread exited&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MBeanRegistry.getInstance().unregisterAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">&quot;Failed to unregister with JMX&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            jmxQuorumBean = <span class="literal">null</span>;</span><br><span class="line">            jmxLocalPeerBean = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Leader选举前的准备"><a href="#Leader选举前的准备" class="headerlink" title="Leader选举前的准备"></a>Leader选举前的准备</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startLeaderElection</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 一开始是自己的选票</span></span><br><span class="line">         <span class="comment">// getCurrentEpoch 版本号</span></span><br><span class="line">         currentVote = <span class="keyword">new</span> <span class="title class_">Vote</span>(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">       &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">         <span class="type">RuntimeException</span> <span class="variable">re</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage());</span><br><span class="line">         re.setStackTrace(e.getStackTrace());</span><br><span class="line">         <span class="keyword">throw</span> re;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 找到自己的地址</span></span><br><span class="line">       <span class="keyword">for</span> (QuorumServer p : getView().values()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (p.id == myid) &#123;</span><br><span class="line">               myQuorumAddr = p.addr;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (myQuorumAddr == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// zk本身提供了几种选举算法 0、1、2</span></span><br><span class="line">       <span class="comment">// 0这种就是基于udp网络连接，不算太可靠，但是如今已经被废弃掉了</span></span><br><span class="line">       <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               udpSocket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(myQuorumAddr.getPort());</span><br><span class="line">               responder = <span class="keyword">new</span> <span class="title class_">ResponderThread</span>();</span><br><span class="line">               responder.start();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 目前选举算法0、1、2都被废弃了，只有3了</span></span><br><span class="line"> <span class="keyword">protected</span> Election <span class="title function_">createElectionAlgorithm</span><span class="params">(<span class="type">int</span> electionAlgorithm)</span>&#123;</span><br><span class="line">       Election le=<span class="literal">null</span>;</span><br><span class="line">       <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">       <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">           le = <span class="keyword">new</span> <span class="title class_">LeaderElection</span>(<span class="built_in">this</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">           le = <span class="keyword">new</span> <span class="title class_">AuthFastLeaderElection</span>(<span class="built_in">this</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">           le = <span class="keyword">new</span> <span class="title class_">AuthFastLeaderElection</span>(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">           <span class="comment">// 用于zk节点之间网络通信的组件</span></span><br><span class="line">           qcm = <span class="keyword">new</span> <span class="title class_">QuorumCnxManager</span>(<span class="built_in">this</span>);</span><br><span class="line">           QuorumCnxManager.<span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> qcm.listener;</span><br><span class="line">           <span class="keyword">if</span>(listener != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">// 启动一个listener，用于监听其他机器发送过来的请求</span></span><br><span class="line">               <span class="comment">// 通过这个组件也可以给其他机器发送请求</span></span><br><span class="line">               listener.start();</span><br><span class="line">               le = <span class="keyword">new</span> <span class="title class_">FastLeaderElection</span>(<span class="built_in">this</span>, qcm);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               LOG.error(<span class="string">&quot;Null listener when initializing cnx manager&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> le;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建网络通信组件QuorumCnxManager</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">QuorumCnxManager</span><span class="params">(QuorumPeer self)</span> &#123;</span><br><span class="line">       <span class="comment">// 这个队列用来存储其他节点发给它的消息</span></span><br><span class="line">       <span class="built_in">this</span>.recvQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Message&gt;(RECV_CAPACITY);</span><br><span class="line">       <span class="comment">// 每个服务器都有一个对应的消息队列，key是sid</span></span><br><span class="line">       <span class="built_in">this</span>.queueSendMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Long, ArrayBlockingQueue&lt;ByteBuffer&gt;&gt;();</span><br><span class="line">       <span class="comment">// 每个服务器都有一个对应的发送工作线，key是sid</span></span><br><span class="line">       <span class="built_in">this</span>.senderWorkerMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Long, SendWorker&gt;();</span><br><span class="line">       <span class="comment">// 用于存储最后一条发送的消息，key是sid</span></span><br><span class="line">       <span class="built_in">this</span>.lastMessageSent = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Long, ByteBuffer&gt;();</span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">cnxToValue</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;zookeeper.cnxTimeout&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(cnxToValue != <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="built_in">this</span>.cnxTO = <span class="keyword">new</span> <span class="title class_">Integer</span>(cnxToValue); </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">this</span>.self = self;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Starts listener thread that waits for connection requests </span></span><br><span class="line">       listener = <span class="keyword">new</span> <span class="title class_">Listener</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listener其实也是一个线程，我们来看看它的run()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">numRetries</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>((!shutdown) &amp;&amp; (numRetries &lt; <span class="number">3</span>))&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">           ss.setReuseAddress(<span class="literal">true</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> self.quorumPeers.get(self.getId()).electionAddr</span><br><span class="line">             .getPort();</span><br><span class="line">           <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port);</span><br><span class="line">           LOG.info(<span class="string">&quot;My election bind port: &quot;</span> + addr.toString());</span><br><span class="line">           setName(self.quorumPeers.get(self.getId()).electionAddr</span><br><span class="line">                   .toString());</span><br><span class="line">           ss.bind(addr);</span><br><span class="line">           <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">             <span class="comment">// 走bio监听连接请求</span></span><br><span class="line">             <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">             setSockOpts(client);</span><br><span class="line">             LOG.info(<span class="string">&quot;Received connection request &quot;</span></span><br><span class="line">                      + client.getRemoteSocketAddress());</span><br><span class="line">             <span class="comment">// 收到建立链接请求</span></span><br><span class="line">             receiveConnection(client);</span><br><span class="line">             numRetries = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           LOG.error(<span class="string">&quot;Exception while listening&quot;</span>, e);</span><br><span class="line">           numRetries++;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">             ss.close();</span><br><span class="line">             Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">             LOG.error(<span class="string">&quot;Error closing server socket&quot;</span>, ie);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">             LOG.error(<span class="string">&quot;Interrupted while sleeping. &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;Ignoring exception&quot;</span>, ie);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       LOG.info(<span class="string">&quot;Leaving listener&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (!shutdown) &#123;</span><br><span class="line">         LOG.error(<span class="string">&quot;As I&#x27;m leaving the listener thread, &quot;</span></span><br><span class="line">                   + <span class="string">&quot;I won&#x27;t be able to participate in leader &quot;</span></span><br><span class="line">                   + <span class="string">&quot;election any longer: &quot;</span></span><br><span class="line">                   + self.quorumPeers.get(self.getId()).electionAddr);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到建立连接请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">receiveConnection</span><span class="params">(Socket sock)</span> &#123;</span><br><span class="line">   <span class="type">Long</span> <span class="variable">sid</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 从输入流中读取来自连接的服务器ID</span></span><br><span class="line">       <span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(sock.getInputStream());</span><br><span class="line">       sid = din.readLong();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (sid == QuorumPeer.OBSERVER_ID) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 如果是 Observer 节点，则随机选择一个标识符。</span></span><br><span class="line"><span class="comment">            * 需要一个值来标识这个连接。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           sid = observerCounter--;</span><br><span class="line">           LOG.info(<span class="string">&quot;Setting arbitrary identifier to observer: &quot;</span> + sid);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// 处理异常，关闭 socket</span></span><br><span class="line">       closeSocket(sock);</span><br><span class="line">       LOG.warn(<span class="string">&quot;Exception reading or writing challenge: &quot;</span> + e.toString());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果当前节点的 ID 小于接收的 sid，关闭新连接，避免多次连接</span></span><br><span class="line">   <span class="keyword">if</span> (sid &lt; self.getId()) &#123; </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 尝试建立新连接之前，必须关闭工作线程。</span></span><br><span class="line">       <span class="type">SendWorker</span> <span class="variable">sw</span> <span class="operator">=</span> senderWorkerMap.get(sid);</span><br><span class="line">       <span class="keyword">if</span> (sw != <span class="literal">null</span>) &#123;</span><br><span class="line">           sw.finish(); </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       LOG.debug(<span class="string">&quot;Create new connection to server: &quot;</span> + sid);</span><br><span class="line">       closeSocket(sock);  <span class="comment">// 关闭旧连接</span></span><br><span class="line">       connectOne(sid);  <span class="comment">// 尝试连接新的 sid</span></span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 启动接收和发送工作线程</span></span><br><span class="line">       <span class="type">SendWorker</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendWorker</span>(sock, sid);</span><br><span class="line">       <span class="type">RecvWorker</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecvWorker</span>(sock, sid, sw);</span><br><span class="line">       sw.setRecv(rw);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检查是否已有对应的发送工作线程</span></span><br><span class="line">       <span class="type">SendWorker</span> <span class="variable">vsw</span> <span class="operator">=</span> senderWorkerMap.get(sid);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 如果存在，则结束已存在的发送工作线程</span></span><br><span class="line">       <span class="keyword">if</span> (vsw != <span class="literal">null</span>) &#123;</span><br><span class="line">           vsw.finish();  </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     	<span class="comment">// 将新的发送工作线程存入映射</span></span><br><span class="line">       senderWorkerMap.put(sid, sw);  </span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 确保发送队列存在</span></span><br><span class="line">       <span class="keyword">if</span> (!queueSendMap.containsKey(sid)) &#123;</span><br><span class="line">           queueSendMap.put(sid, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;ByteBuffer&gt;(</span><br><span class="line">                   SEND_CAPACITY));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 启动发送和接收工作线程</span></span><br><span class="line">       sw.start();</span><br><span class="line">       rw.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SendWorker的run()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   threadCnt.incrementAndGet();  <span class="comment">// 增加线程计数</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     	<span class="comment">// 启动时的重试机制，确保上次未成功发送的消息能够再次尝试发送</span></span><br><span class="line">       <span class="comment">// 获取要发送的消息队列</span></span><br><span class="line">       ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span><br><span class="line">       <span class="keyword">if</span> (bq == <span class="literal">null</span> || isSendQueueEmpty(bq)) &#123;</span><br><span class="line">           <span class="comment">// 如果队列为空，发送最后一条消息</span></span><br><span class="line">           <span class="type">ByteBuffer</span> <span class="variable">b</span> <span class="operator">=</span> lastMessageSent.get(sid);</span><br><span class="line">           <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">               LOG.debug(<span class="string">&quot;Attempting to send lastMessage to sid=&quot;</span> + sid);</span><br><span class="line">               send(b);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       LOG.error(<span class="string">&quot;Failed to send last message. Shutting down thread.&quot;</span>, e);</span><br><span class="line">       <span class="built_in">this</span>.finish();  <span class="comment">// 处理异常，关闭线程</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     	<span class="comment">// 这里是持续的消息发送循环。</span></span><br><span class="line">       <span class="keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="type">ByteBuffer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ArrayBlockingQueue&lt;ByteBuffer&gt; bq = queueSendMap.get(sid);</span><br><span class="line">               <span class="keyword">if</span> (bq != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 从队列中获取要发送的消息</span></span><br><span class="line">                   b = pollSendQueue(bq, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   LOG.error(<span class="string">&quot;No queue of incoming messages for server &quot;</span> + sid);</span><br><span class="line">                   <span class="keyword">break</span>;  <span class="comment">// 如果队列不存在，退出循环</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                   lastMessageSent.put(sid, b);  <span class="comment">// 记录最后发送的消息</span></span><br><span class="line">                   send(b);  <span class="comment">// 发送消息</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               LOG.warn(<span class="string">&quot;Interrupted while waiting for message on queue&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       LOG.warn(<span class="string">&quot;Exception when using channel: for id &quot;</span> + sid + <span class="string">&quot; my id = &quot;</span> + self.getId() + <span class="string">&quot; error = &quot;</span> + e);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">this</span>.finish();  <span class="comment">// 完成后关闭线程</span></span><br><span class="line">   LOG.warn(<span class="string">&quot;Send worker leaving thread&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RecvWorker的run()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   threadCnt.incrementAndGet();  <span class="comment">// 增加线程计数</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (running &amp;&amp; !shutdown &amp;&amp; sock != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 读取第一个整数，确定消息的长度</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> din.readInt();</span><br><span class="line">           <span class="keyword">if</span> (length &lt;= <span class="number">0</span> || length &gt; PACKETMAXSIZE) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Received packet with invalid packet: &quot;</span> + length);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 分配新的 ByteBuffer 来接收消息</span></span><br><span class="line">           <span class="type">byte</span>[] msgArray = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">           din.readFully(msgArray, <span class="number">0</span>, length);</span><br><span class="line">           <span class="type">ByteBuffer</span> <span class="variable">message</span> <span class="operator">=</span> ByteBuffer.wrap(msgArray);</span><br><span class="line">           <span class="comment">// 将消息添加到接收队列，就是QuorumCnxManager里的recvQueue</span></span><br><span class="line">           addToRecvQueue(<span class="keyword">new</span> <span class="title class_">Message</span>(message.duplicate(), sid)); </span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       LOG.warn(<span class="string">&quot;Connection broken for id &quot;</span> + sid + <span class="string">&quot;, my id = &quot;</span> + self.getId() + <span class="string">&quot;, error = &quot;</span>, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       LOG.warn(<span class="string">&quot;Interrupting SendWorker&quot;</span>);</span><br><span class="line">       sw.finish();  <span class="comment">// 结束发送工作线程</span></span><br><span class="line">       <span class="keyword">if</span> (sock != <span class="literal">null</span>) &#123;</span><br><span class="line">           closeSocket(sock);  <span class="comment">// 关闭 socket 连接</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/../img/articles/zk/zk%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-01.jpg" alt="zk源码"></p>
]]></content>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
</search>
